# Design Pattern
* 소프트웨어 설계의 특정 문맥에서 공통적인 문제에 대해 재사용 가능한 해결책.
* 프로그래밍 언어를 만들 때 참고한 것으로, 언어에 대한 심도있는 이해를 위해서는 디자인 패턴에 대한 고찰이 필요하다.
* Gang of Four의 패턴 이론으로 불필요한 반복을 지양한다.
* “바퀴를 다시 발명하지 마라.(Don’t reinvent the wheel.)”
<br><br>



## `[3대 분류]`
* 생성 패턴, 구조 패턴, 행위 패턴 3가지로 크게 나눌 수 있다.
* 단위 패턴의 갯수는 총 23개.
* 생성 패턴
    * 객체 생성에 관련된 패턴.
    * 인스턴스화에 대한 패턴.
    * 프로그램 구조에 영향을 주지 않는 것을 추구한다.
    * 싱글턴, 팩토리 메서드, 추상 팩토리, 빌더, 프로토타입
* 구조 패턴
    * 객체와 클래스를 더 큰 구조로 조립하는 패턴.
    * 자료구조에 대한 패턴.
    * 효율성 유지를 추구한다.
    * 어댑터, 브릿지, 컴포지트, 데코레이터, 파사드, 플라이 웨이트, 프록시
* 행위 패턴
    * 알고리즘과 객체 간의 책임을 할당하는 패턴.(책임이란 반드시 리턴을 주는 것을 의미함)
    * 함수에 대한 패턴.
    * 작업 분배를 추구한다.
    * 이터레이터, 커맨드, 비지터, 책임 연쇄, 옵저버, 중재자, 상태, 메멘토, 템플릿 메서드, 전략, 인터프리터
<br><br>

### [자주 쓰는 핵심 패턴]
* 생성 : 싱글턴, 추상 팩토리, 팩토리 메서드
* 구조 : 데코레이터, 프록시, 컴포지트, 어댑터, 파사드
* 행동 : 템플릿 메서드, 상태, 이터레이터, 전략, 옵저버
<br><br>



## `[생성 패턴]`

### [팩토리 패턴]
* 객체 생성 과정을 담당할 별도의 클래스를 선언한다.
* 특징
    * 객체 생성 과정에서 발생하는 새로운 키워드들이 일으키는 문제를 방지한다.
    * 객체의 구조적 결합도와 의존성을 줄여 느슨하게 만들어준다.
* 예시
    * Americano(), Cafe_Latte(), Vanilla_Latte() 클래스 생성.
    * CoffeeFactory() 클래스를 만들고 if문을 돌린다.
    * 객체의 type이 아메리카노면 Americano() 클래스 실행.
* 장점
    * 코드에서 생성과 관련된 모든 처리를 별도의 클래스 객체로 통일.
    * 유연하고 확장된 코드 작성.
    * 어떤 객체를 생성할지 몰라도 상관 없다.
* 단점
    * 번거롭게 새로운 클래스를 만들어야 한다.
<br><br>

### [싱글턴 패턴]
* 클래스에서 하나의 객체만 생성할 수 있도록 제한한다.
* 특징
    * 복수의 시스템이 하나의 자원에 접근하고자 할 수 있다.
    * 여러번 생성하더라도 언제나 똑같은 유일한 객체를 생성할 수 있다.
* 예시
    * 클래스를 생성할 때 new 메서드와 init 메서드를 수정한다.
    * new 메서드에서 _instance 속성이 없을 때만 실행.
    * init 메서드에서 _init 속성이 없을 때만 실행.
* 장점
    * 여러번 생성하더라도 언제나 똑같은 유일한 객체를 생성할 수 있다.
* 단점
    * 싱글턴 패턴으로 생성한 자원은 프로그램이 종료될 때까지 메모리에 저장된다.
<br><br>

### [팩토리 메서드 패턴]
* 추상화를 통해 '선언하는 메서드'와 '구현하는 메서드'를 분리한다.
* 특징
    * 팩토리 패턴과 템플릿 메서드 패턴이 결합된 패턴.
    * 실제로 객체를 생성하는 것은 서브 클래스.
* 예시
    * Americano(), Cafe_Latte(), Vanilla_Latte() 클래스 생성.
    * Coffee() 클래스를 만들고 if문을 돌린다.
    * 객체의 type이 아메리카노면 Americano() 클래스 실행.
    * CoffeeFactory() 클래스 생성.
    * MegaCoffeeFactory(), StarCoffeeFactory() 서브 클래스 생성.
    * CoffeeFactory()로 부터 상속 받아서 실제 구현은 서브 클래스가 함.
* 장점
    * 더 유연하고 관리하기 편하다.
* 단점
    * 더 번거롭게 클래스를 만들어야 한다.
<br><br>

### [추상 팩토리 패턴]
* 팩토리 패턴을 여러개 만들고 그룹으로 묶어 하나로 관리한다.
* 특징
    * 객체 생성 과정에서 그룹화가 필요할 경우 주로 사용한다.
    * 클래스 간 관계 구성은 같지만 세부 동작 수행이 다른 경우 사용한다.
* 예시
    * CarFactory() 클래스.
    * DoorFactory() 클래스 -> UsDoorFactory(), KrDoorFactory() 서브 클래스.
    * TireFactory() 클래스 -> UsTireFactory(), KrTireFactory() 서브 클래스.
    * CarFactory() 클래스에 서브 클래스 UsCarFactory(), KrCarFactory() 만들고 묶어줌.
* 장점
    * 팩토리를 쉽게 수정할 수 있다.
* 단점
    * 완전히 새로운 구성의 객체에는 사용할 수 없다.
<br><br>

### [빌더 패턴]
* 복잡한 구조를 가진 복합 객체의 생성 과정을 분리하여 처리한다.
* 특징
    * 복합 객체의 생성 과정을 단계별로 분리하여 일반화 한다.
    * 추상 클래스 Builder()를 생성하여 복합 객체 로직을 짜놓는다.
* 예시
    * MacBuilder() 클래스.
    * init 메서드에서 __display, __cpu, __ram, __ssd 매개변수를 받음.
    * @property 데코레이터르 이용해서 매개변수 리턴.
* 장점
    * 객체의 속성이 변하지 않는다.
    * 매개변수에 빈값을 넣으면 에러가 나므로 반드시 입력해야 한다.
* 단점
    * 복잡하게 코드를 많이 쳐야한다.
<br><br>

### [프로토타입 패턴]
* 미리 만들어둔 객체를 복제해 생성한다.
* 특징
    * 인스턴스를 새로 만드는 것이 아니라 복제하는 것.
    * 인스턴스화 과정이 생략되어 생성 로직에 소모되는 처리 비용과 자원을 절약할 수 있다.
* 예시
    * 여기 개발자 양성소가 있다.
    * 개발자는 3년차, 파이썬 5Lv, 자바 5Lv을 달성하면 사용 가능하다.
    * 년차와 언어의 Lv은 메서드를 사용해야 업그레이드 되고 총 13회 해야한다.
    * 인스턴스를 만들 경우 번거로우므로 복사하는 것을 택한다.
* 장점
    * 비용을 줄일 수 있다.
* 단점
    * 순환 구조의 생성 시 불가능하다.
<br><br>



## `[구조 패턴]`

### [어댑터 패턴]
* 코드를 재사용하기 위해 구조를 변경한다.
* 특징
    * 코드를 재사용, 보정하기 위한 인터페이스를 만든다.
    * 오래된 레거시 코드나 라이브러리를 재사용할 때 유용하다.
    * 호환되지 않는 인터페이스를 가진 코드를 결함하여 같이 동작할 수 있도록 도와준다.
* 예시
    * 레거시 이미지인 RGB를 최신 이미지인 HDMI로 변환해야 한다.
    * HDMIConverter()라는 어댑터 클래스 생성.
    * RGB 클래스를 인풋하여 HDMI가 리턴되게 한다.
* 장점
    * 복잡한 객체 구조를 간단하게 정리할 수 있다.
* 단점
    * 인터페이스를 통과하는 과정이 추가되므로 느려진다.
<br><br>

### [브릿지 패턴]
* 객체에서 기능 부분과 구현 부분을 분리하여 독립적으로 관리한다.
* 특징
    * 기존 시스템에 새로운 기능들을 지속적으로 추가할 때 유리하다.
    * 기존 프로그램의 변경 없이 기능을 확장할 수 있다.
    * 런타임 시점에 기능과 구현이 결정된다.
* 예시
    * Shape(원, 네모)와 Color(R, G, B)를 조합하는 경우 총 6개의 클래스가 필요하다.
    * 기능부인 Shape() 추상 클래스와 구현부인 Color() 추상 클래스로 분리한다.
    * Shape()클래스와 Color()클래스를 연결한다. (브릿지)
* 장점
    * 각 부분의 독립적인 확장, 추가가 가능하다.
* 단점
    * 단순한 구조에서는 오히려 손해다.
<br><br>

### [컴포지트 패턴]
* 객체들의 관계를 트리 구조화(재귀적 결합)를 통해 객체를 확장한다.
* 컴포지트 : 복합 객체, 객체가 다른 객체를 포함하는 것.
* 특징
    * 객체의 상위, 하위 체계를 파악할 수 있다.
    * 일대일, 다대일 객체 작업을 처리하기 쉽다.
    * 디렉토리 - 파일과 같은 트리 구조와 유사하다.
* 예시
    * FileSystem()라는 컴포넌트 클래스.
    * 이 클래스는 getSize(), remove() 메서드를 가진다.
    * File()이라는 리프 클래스와 Directory()라는 컴포지트 클래스.
    * Directory()는 다른 파일이나 폴더를 포함할 수 있다.
    * 컴포지트가 특정 메서드를 사용하면, 하위 객체들도 해당 메서드를 사용한다.
* 장점
    * 묶어서 동시에 연산하거나 관리할 수 있다.
* 단점
    * 뎁스가 길어지면 디버깅이 어려워진다.
<br><br>

### [데코레이터 패턴]
* 객체에 상황과 용도에 따라 새로운 책임을 추가, 확장한다.
* 특징
    * 코드를 추가하지 않고 책임을 확장한다.
    * 유연하고 간편하게 기능을 확장한다.
* 예시
    * 여기 케이크 장식을 위한 코드가 있다.
    * CakeConcrete()클래스는 케이크 본체이다.
    * 케이크 위에 올라갈 장식은 딸기, 초코, 민트가 있다.
    * 장식에 대한 추상클래스 CakeDeco()클래스 생성.
    * 하위 클래스로 Strawberry(), Choco(), Mint() 생성.
    * 호출 시 본체에 데코 종류 및 갯수를 결정.
* 장점
    * 상속 보다 더 융통성 있게 설계할 수 있다.
    * 호출 시 결정되므로 동적이다.
* 단점
    * 유사한 성질의 작은 클래스가 반복되어 작성된다.
<br><br>

### [파사드 패턴]
* 클라이언트에게 시스템의 복잡성을 숨기고, 사용하기 편하도록 간단한 인터페이스를 제공한다.
* 특징
    * 협업과 대형 시스템에 유리하여 라이브러리, 패키지, API 설계에 필수적이다.
    * 파사드 추상 클래스는 클라이언트가 사용할 인터페이스를 구현한다.
    * 파사드 추상 클래스는 각종 서브시스템 클래스에 접근 가능하다.
* 예시
    * 여기 사용자가 API를 사용하려고 한다.
    * SubSystemA(), SubSystemB() 클래스는 클라이언트가 직접 접근할 수 없다.
    * Facade() 추상 클래스는 init메서드를 통해 모든 하위 시스템에 접근한다.
    * Facade() 추상 클래스에는 작업의 모든 순서도 기록되어 있기에 클라이언트는 단순히 Facade()클래스를 호출하기만 하면 된다.
* 장점
    * 클라이언트는 서브시스템의 복잡한 기능을 알 필요 없다.
    * 클라이언트는 복잡한 사용 순서를 알 필요 없다.
    * 서브시스템이 은닉화되어 보호된다.
* 단점
    * 클라이언트는 가끔 원인 불명의 에러를 마주한다.
<br><br>

### [플라이웨이트 패턴]
* 객체를 공유하고 재사용하여 메모리를 절약할 수 있다.
* 특징
    * 공유 객체를 관리하기 위해 별도 저장소를 갖고 이를 '공유 저장소'라고 한다.
    * 팩토리 클래스에 공유 저장소를 추가하여 기존 객체와 중복되진 않았는지, 참조할게 있는지 확인한다.
* 예시
    * 여기 해바라기 사진에서 잎에 원을 그리는 작업이 있다.
    * 잎이 3천개 있으면 해바라기 사진 객체를 3천개 만들어야 한다.
    * LeapFactory() 클래스 생성. 기존 객체와 중복성 확인.
    * Circle() 클래스에서 해바라기 사진 공유 객체를 가져와 원 객체 생성.
* 장점
    * 메모리를 절약할 수 있다.
* 단점
    * 공유 객체의 인스턴스를 수정하는 상황이면 에러가 발생한다.
<br><br>

### [프록시 패턴]
* 객체 접근을 제어하기 위해 중간 단계에 매니저(프록시)를 위치시킨다.
* 특징
    * 클라이언트가 객체를 직접 호출할 수 없다. 프록시에게 호출 요청.
    * 프록시는 객체를 호출 요청 후 응답을 받은 후 클라이언트에게 전달한다.
    * 프록시가 객체 호출을 거절하면 객체 생성 자체가 안된다.
* 예시
    * 여기 아주 바쁜 배우와 그의 매니저가 있다.
    * Actor() 클래스에는 busy 메서드와 avilable 메서드가 있다.
    * Manager() 클래스는 Actor.getStatus 메서드에 접근할 수 있다.
    * Actor() 클래스의 응답에 따라 클라이언트에 값을 전달한다.
* 장점
    * 무거운 객체 생성 과정을 유보할 수 있다.
* 단점
    * 자주 생성하는 객체일 경우 느려진다.
<br><br>



## `[행위 패턴]`

### [이터레이터 패턴]
* 집합체를 통해 원소에 순차적으로 접근할 수 있는 방법을 제공한다.
* 특징
    * 내부 구조를 노출하지 않는다.
    * 공통 행동을 모든 원소에 대하여 반복 수행할 수 있다.
* 예시
    * 여기 파이썬의 iter 메서드 기능을 모방하는 작업이 있다.
    * List() 클래스는 생성 시 item을 넣는다.
    * get_item 메서드와 iter 메서드를 가지고 있다.
    * ListIterator() 클래스는 next 메서드를 가지고 인덱스를 바꿔가며 List() 클래스의 get_item 메서드를 실행할 수 있다.
* 장점
    * 내부 구조를 몰라도 모든 항목에 접근 가능하다.
* 단점
    * 클래스가 늘어난다.
<br><br>

### [커맨드 패턴]
* 행동의 호출을 객체로 캡슐화하여 실행한다.
* 특징
    * 내부 작업을 수행하는 객체와 작업들을 실행하는 객체로 분리한다.
    * 일련의 작업을 하나의 메서드로 실행한다. execute 메서드.
* 예시
    * Command() 클래스에는 execute 메서드가 있다.
    * execute 메서드는 작업을 실행하는 트리거 역할만 한다.
    * Receiver() 클래스에는 내부 작업을 수행하는 메서드가 있다.
    * 클라이언트는 내부 작업을 직접 불러오지 않고 Invoker() 클래스에 요청, Invoker()는 Command()의 execute 메서드를 실행한다.
    * MTV 패턴 설계도 같은 원리.
* 장점
    * 결합도가 낮아진다.
    * 내부 작업이 캡슐화 되어 숨겨진다.
    * 명령을 추가하는게 쉽다.
* 단점
    * 작업 개수 마다 클래스가 늘어난다.
<br><br>

### [비지터 패턴]
* 방문자와 방문 공간을 분리하여 방문 공간이 방문자를 맞이할 때, 이후에 대한 행동을 방문자에게 위임한다.
* 특징
    * 자료구조와 알고리즘이 분리되므로 알고리즘 추가가 쉽다.
    * 알고리즘은 곧 방문자로, 알고리즘 추가 시 방문자를 추가한다.
    * 자료구조보다 알고리즘이 자주 바뀌는 경우 유리하다.
* 예시
    * 여기 Json 이나 Xml로 uuid를 만드는 코드가 있다.
    * 방문공간 Element() 클래스에서 uuid를 만들 수 있다. 다만 그뿐이다.
    * 방문공간은 내부적으로 Visitor.visit 메서드를 호출한다.
    * 방문자 Visitor() 클래스는 형식이 Json 혹은 Xml 임을 확인한다.
    * visit 메서드를 통해 Element() 클래스가 JsonElement()를 호출할지, XmlElement()를 호출할지 결정해준다.
* 장점
    * 자료구조와 알고리즘이 독립적이다.
* 단점
    * 자료구조가 추가되는 경우 복잡한 추가 과정이 필요하다.
<br><br>

### [책임 연쇄 패턴]
* 객체 메시지의 송신과 수신을 분리해서 처리한다.
* 특징
    * 여러 클래스에게 책임에 대한 균등한 기회를 제공한다.
    * 클라이언트가 요청한 이벤트의 상태를 어떤 클래스가 처리할지 모른다.
    * 사슬처럼 엮인 클래스에서 순차적으로 탐색하며 이벤트를 처리한다.
* 예시
    * 여기 양수, 음수, 0 에 대하여 각각 다르게 처리하는 계산기가 있다.
    * Chain() 클래스는 PositiveProcess() 클래스 -> NegativeProcess() 클래스 -> ZeroProcess() 클래스 순으로 처리하도록 설계해둔다.
    * 각각의 Process() 클래스는 조건문을 통해 본인이 처리할 수 있는 숫자인지 판단하고 처리여부를 속성값에 저장한다.
    * 처리가 완료되었을 경우 리턴한다.
* 장점
    * 클라이언트는 처리에 대한 내부 구조나 순서를 알 필요 없다.
    * 처리가 추가되면 이어서 작성할 수 있다.
* 단점
    * 순차적 탐색은 곧 느린 것을 뜻한다.
<br><br>

### [옵저버 패턴]
* 동작을 처리하는 주체자와 상태를 감시하는 감시자를 분리한다.
* 특징
    * 상태가 변경되면 주체는 감시자에게 상태 변화를 통보한다.
    * 통보를 받은 감시자는 주체 관찰 정보를 업데이트 한다.
    * 감시자가 여러개일 수 있다.
    * 단방향일 경우 게시-구독(Publish-Subscribe) 패턴이라고 부른다.
* 예시
    * Subject() 클래스는 관찰 대상으로 동작을 처리한다.
    * Subject() 클래스는 attach, detach 메서드로 옵저버를 관리하며 notify 메서드로 상태 변화를 통보한다.
    * Observer() 클래스는 notify 메서드에로 호출될 시 update 메서드를 사용한다.
* 장점
    * 실시간으로 한 객체의 변화를 다른 객체에 전파할 수 있다.
* 단점
    * 상태 관리를 해야한다.
<br><br>

### [중재자 패턴]
* 분산된 다수의 객체 역할과 관계를 하나의 객체로 관리할 수 있다.
* 특징
    * M:N 관계를 가진 객체를 1:1 관계로 변경할 수 있다.
    * 다른 객체에 직접 접근하지 않고 중재자를 통해 호출한다.
* 예시
    * 여기 채팅 프로그램이 있다.
    * Mediator() 클래스는 사용자 추가와 제거를 할 수 있고, 메시지 전송을 할 수 있다.
    * Colleague() 클래스는 메시지를 받고 보내는 동작만 한다.
    * Colleague()가 동작을 하면 Mediator()가 내용을 받아서 전송을 도와준다.
* 장점
    * 객체간의 통신이 없어 의존성이 줄어든다.
* 단점
    * 관리해야할 호출 수가 늘어난다.
<br><br>

### [상태 패턴]
* 조건에 따른 별개의 동작을 객체에 캡슐화하여 독립된 동작으로 구분한다.
* 특징
    * 클래스 내에 메서드로 분리하거나 조건문을 돌리지 않는다.
    * 모든 동작은 서브 클래스로 만든다.
    * 분리된 동작들은 독립적이고 각자 다른 행위를 전담한다.
    * 동작에 의해 클래스 자체가 변경되지 않고 상태 클래스가 변한다.
* 예시
    * 여기 on/off 동작이 있는 라디오와 티비가 있다.
    * TurnOn() 클래스는 오직 물체를 on 상태로 변경되게 한다.
    * TurnOff() 클래스는 오직 물체를 off 상태로 변경되게 한다.
    * Radio(), TV() 클래스는 off 상태로 생성된다.
    * 두 클래스는 모두 상태 클래스인 PowerState() 상태값을 가진다.
* 장점
    * 동작을 늘리기 편하다.
    * 동작에 의해 클래스 자체가 변하지 않는고 상태 클래스만 변한다.
* 단점
    * 관리할 클래스 수가 늘어난다.
<br><br>

### [메멘토 패턴]
* 객체의 상태를 다른 객체에 저장하여 이전 상태로 복구할 수 있다.
* 특징
    * 상태를 갖는 클래스가 있다.
    * 상태를 갖는 클래스를 관리하고 변화 과정을 기록한 클래스가 있다.
* 예시
    * 여기 메멘토 패턴 구조가 있다.
    * Originator() 클래스는 현재 상태를 갖는다.
    * Mementor() 클래스는 특정 시점의 상태를 갖는다.
    * Mementor()는 GetState 와 SetState 메서드로 상태를 주고 받을 수 있다.
    * CareTaker() 클래스는 Mementor()의 n번째 상태를 모두 기록한다.
* 장점
    * 상태 복구가 쉽다.
* 단점
    * 상태를 지속 저장하는데 메모리 부담이 있다.
<br><br>

### [템플릿 메서드 패턴]
* 메서드를 이용해 각 단계를 템플릿화(구조화)하고 행동을 구분한다.
* 특징
    * 공통된 로직을 분리하여 틀처럼 만든다.
    * 로직 전체는 그대로 두고 일부분만 수정할 때 유용하다.
    * 공통되지 않은 작은 로직을 처리하는 메서드는 따로 존재한다.
* 예시
    * 여기 햄버거를 만드는 가게가 있다.
    * BurgerTemplate() 클래스는 햄버거를 만드는 전체 과정 및 순서 이다.
    * 이 템플릿 클래스의 make 메서드로 Burger() 클래스를 호출한다.
    * Burger() 클래스는 햄버거를 만드는 공통 과정이 모여있다.
    * ChickenBurger() 클래스와 BulgogiBurger() 클래스는 비공통 과정만 담고 있고, BurgerTemplate() 클래스로부터 공통 과정과 순서를 상속 받는다.
* 장점
    * 중복된 코드를 줄일 수 있다.
    * 객체지향 그자체. (캡슐화, 상속, 추상화)
* 단점
    * 클래스를 넘나들며 충돌이 일어날 수 있다.
<br><br>

### [전략 패턴]
* 객체 내부에서 사용하는 로직들을 모두 객체로 만들고, 교환해서 사용할 수 있다.
* 특징
    * 로직들이 모두 객체화 되며 캡슐화 된다.
    * 알고리즘(로직)이 다양하게 많을 때 유용하다.
* 예시
    * 여기 승용차 혹은 SUV에 기름을 넣는 주유소가 있다.
    * Strategy() 클래스는 cartype 메서드를 갖는다.
    * Strategy() 클래스는 Car() 클래스에서 context에 대한 정보(승용차 혹은 SUV)를 가져온다.
    * cartype 메서드는 정보를 바탕으로 Sedan() 클래스와 SUV() 클래스를 호출할 수 있다.
    * Strategy() 클래스의 oil 메서드를 사용하면 각 클래스의 oil 메서드를 호출하여 사용한다.
* 장점
    * 런타임 도중에 로직을 변경할 수 있다.
* 단점
    * 로직이 늘어날 때마다 클래스가 추가된다.
<br><br>

### [인터프리터 패턴]
* 간단한 언어적 문법을 정의하고 이를 사용해 시스템을 해석할 수 있다.
* 특징
    * 추상화된 언어 문법을 만든다.
    * 해석을 담당하는 인터프리터가 별도로 있다.
* 예시
    * 여기 MySQL이 있다.
    * Expression() 클래스는 각각의 행위 클래스를 갖고 있다.
    * SELECT, FROM, WHERE 행위 클래스는 각각 DB 상호작용 로직을 갖는다.
    * Context() 클래스는 DB 세계에 대한 문법 체계(table, column, row 등)를 갖고있다.
    * Interpreter() 클래스는 Context() 클래스에서 문법을 참조하여 각각의 행위를 해석한다.
* 장점
    * 특정 로직을 자주 쓸 때 편하다.
    * 로직 추가가 쉽다.
* 단점
    * 문법 체계를 정립해야한다.
<br><br>