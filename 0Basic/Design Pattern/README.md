# Design Pattern
* 소프트웨어 설계의 특정 문맥에서 공통적인 문제에 대해 재사용 가능한 해결책.
* 프로그래밍 언어를 만들 때 참고한 것으로, 언어에 대한 심도있는 이해를 위해서는 디자인 패턴에 대한 고찰이 필요하다.
* Gang of Four의 패턴 이론으로 불필요한 반복을 지양한다.
* “바퀴를 다시 발명하지 마라.(Don’t reinvent the wheel.)”

## `[3대 분류]`
* 생성 패턴, 구조 패턴, 행위 패턴 3가지로 크게 나눌 수 있다.
* 단위 패턴의 갯수는 총 23개.
* 생성패턴은 인스턴스화에 대한 패턴, 구조패턴은 자료구조에 대한 패턴, 행위 패턴은 함수에 대한 패턴.
* 생성 패턴
    * 객체 생성에 관련된 패턴. 
    * 객체 생성이 프로그램 구조에 영향을 주지 않는 것을 추구한다.
    * 싱글 턴, 팩토리 메서드, 추상 팩토리, 빌더, 프로토타입
* 구조 패턴
    * 객체와 클래스를 더 큰 구조로 조립하는 패턴.
    * 효율성 유지를 추구한다.
    * 어댑터, 브릿지, 컴포지트, 데코레이터, 파사드, 플라이 웨이트, 프록시
* 행위 패턴
    * 알고리즘과 객체 간의 책임을 할당하는 패턴. (책임은 반드시 리턴을 주는 것을 의미함)
    * 작업 분배를 추구한다.
    * 책임 연쇄, 커맨드, 인터프리터, 이터레이터, 중재자, 메멘토, 옵서버, 상태, 전략, 템플릿 메서드, 비지터
<br><br>


## `[생성 패턴]`

### [팩토리 패턴]
* 객체 생성 과정을 담당할 별도의 클래스를 선언한다.
* 특징
    * 객체 생성 과정에서 발생하는 새로운 키워드들이 일으키는 문제를 방지한다.
    * 객체의 구조적 결합도와 의존성을 줄여 느슨하게 만들어준다.
* 예시
    * Americano(), Cafe_Latte(), Vanilla_Latte() 클래스 생성.
    * CoffeeFactory() 클래스를 만들고 if문을 돌린다.
    * 객체의 type이 아메리카노면 Americano() 클래스 실행.
* 장점
    * 코드에서 생성과 관련된 모든 처리를 별도의 클래스 객체로 통일.
    * 유연하고 확장된 코드 작성.
    * 어떤 객체를 생성할지 몰라도 상관 없다.
* 단점
    * 번거롭게 새로운 클래스를 만들어야 한다.
<br><br>

### [싱글턴 패턴]
* 클래스에서 하나의 객체만 생성할 수 있도록 제한한다. 생성된 객체는 어디서든 접근할 수 있게 공유한다.
* 특징
    * 복수의 시스템이 하나의 자원에 접근하고자 할 수 있다.
    * 여러번 생성하더라도 오직 하나의 유일한 객체를 생성할 수 있다.
* 예시
    * 클래스를 생성할 때 new 메서드와 init 메서드를 수정한다.
    * new 메서드에서 _instance 속성이 없을 때만 실행.
    * init 메서드에서 _init 속성이 없을 때만 실행.
* 장점
    * 여러번 생성하더라도 오직 하나의 유일한 객체를 생성할 수 있다.
* 단점
    * 싱글턴 패턴으로 생성한 자원은 프로그램이 종료될 때까지 메모리에 저장된다.
<br><br>

### [팩토리 메서드 패턴]
* 팩토리 패턴에서 확장된 패턴으로, 추상화를 통해 '선언하는 메서드'와 '구현하는 메서드'를 분리한다.
* 특징
    * 팩토리 패턴과 템플릿 메서드 패턴이 결합된 패턴.
    * 실제로 객체를 생성하는 것은 서브 클래스.
* 예시
    * Americano(), Cafe_Latte(), Vanilla_Latte() 클래스 생성.
    * Coffee() 클래스를 만들고 if문을 돌린다.
    * 객체의 type이 아메리카노면 Americano() 클래스 실행.
    * CoffeeFactory() 클래스 생성.
    * MegaCoffeeFactory(), StarCoffeeFactory() 서브 클래스 생성.
    * CoffeeFactory()로 부터 상속 받아서 실제 구현은 서브 클래스가 함.
* 장점
    * 더 유연하고 관리하기 편하다.
* 단점
    * 더 번거롭게 클래스를 만들어야 한다.
<br><br>

### [추상 팩토리 패턴]
* 팩토리 패턴을 여러개 만들고 그룹으로 묶어 하나로 관리한다.
* 특징
    * 객체 생성 과정에서 그룹화가 필요할 경우 주로 사용한다.
    * 클래스 간 관계 구성은 같지만 세부 동작 수행이 다른 경우 사용한다.
* 예시
    * CarFactory() 클래스.
    * DoorFactory() 클래스 -> UsDoorFactory(), KrDoorFactory() 서브 클래스.
    * TireFactory() 클래스 -> UsTireFactory(), KrTireFactory() 서브 클래스.
    * CarFactory() 클래스에 서브 클래스 UsCarFactory(), KrCarFactory() 만들고 묶어줌.
<br><br>

### [빌더 패턴]
* 복잡한 구조를 가진 복합 객체의 생성 과정을 분리하여 처리한다.
* 특징
    * 복합 객체의 생성 과정을 단계별로 분리하여 일반화 한다.
    * 추상 클래스 Builder()를 생성하여 복합 객체 로직을 짜놓는다.
* 예시
    * MacBuilder() 클래스.
    * init 메서드에서 __display, __cpu, __ram, __ssd 매개변수를 받음.
    * @property 데코레이터르 이용해서 매개변수 리턴.
* 장점
    * 객체의 속성이 변하지 않는다.
    * 매개변수에 빈값을 넣으면 에러가 나므로 반드시 입력해야 한다.
* 단점
    * 복잡하게 코드를 많이 쳐야한다.
<br><br>

### [프로토타입 패턴]
* 미리 만들어둔 객체를 복제해 생성하는 패턴이다.
* 특징
    * 인스턴스를 새로 만드는 것이 아니라 복제하는 것.
    * 인스턴스화 과정이 생략되어 생성 로직에 소모되는 처리 비용과 자원을 절약할 수 있다.
* 예시
    * 여기 개발자 양성소가 있다.
    * 개발자는 3년차, 파이썬 5Lv, 자바 5Lv을 달성하면 사용 가능하다.
    * 년차와 언어의 Lv은 메서드를 사용해야 업그레이드 되고 총 13회 해야한다.
    * 인스턴스를 만들 경우 번거로우므로 복사하는 것을 택한다.
* 장점
    * 비용을 줄일 수 있다.
* 단점
    * 순환 구조의 생성 시 불가능하다.
<br><br>



## `[구조 패턴]`

### [어댑터 패턴]
* 코드를 재사용하기 위해 구조를 변경하는 패턴이다.
* 특징
    * 














### [참고]
* 팩토리 메서드 : 클래스의 프로퍼티를 변경하거나 확장해야 할 때 사용하는 패턴.
    * 모든 코드를 하나하나 수정할 필요가 없으며, factory 메서드를 사용하면 된다.
    * 또한, 2차원 형태의 데이터를 가져올 때, 한줄 한줄 읽는 것이 아니라 한번에 2차원을 읽는다. (ex. [ ][ ] = abc.Abc( ))
* 프로토타입 : 생성할 클래스들의 타입이 프로토타입인 인스턴스로 부터 결정되는 패턴.
    * 객체를 만들기 위해 자기 자신을 복제한다.
    * 모델링 과정에서는 (전처리 - 프로세스 - 테스트)를 계속 반복되는데, 이과정도 프로토타입 패턴이다.
    * 팩토리 패턴과 반대되는 개념. (모델링 = 프로토타입, 완성 후 배포 = 팩토리)
* 상태 : 객체 내부에 또 다른 객체를 만들고, 이를 상태 객체로 정의하는 패턴.
    * 메인 객체 = field, 서브 객체 = state
    * (ex. 파이썬의 클로저, SQL의 서브쿼리)
* 아토믹 : 단계적으로 추상적인 것에서 구체화 하는 설계 패턴.
    * 아톰 -> 몰레큘 -> 유기체 -> 템플렛 -> 페이지
* https://hirlawldo.tistory.com/category/%EA%B0%9C%EB%B0%9C/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4