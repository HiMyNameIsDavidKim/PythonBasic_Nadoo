# Classification of Algorithm

## `[알고리즘의 분류]`
* 설계기법 별 분류 : 완전탐색(Brute Force, 순열, 재귀, 비트마스크, DFS, BFS), 탐욕, 분할 정복, 동적 프로그래밍, 백트래킹
* 주제 별 분류 : 탐색(선형탐색, 이진탐색, 해시탐색), 정렬(버블정렬, 선택정렬, 삽입정렬, 병합정렬, 힙정렬, 퀵정렬, 기수정렬), 그래프, 트리
<br><br>



## `[완전탐색]`
* 모든 경우를 다 시도해보는 방법.
* 장점 : 구현이 쉽다.
* 단점 : 시간이 오래걸린다.
<br><br>

### [완전탐색_Brute Force]
* 모든 경우를 다 시도해보는 방법.
    * 가장 무식한 방법이다. 알고리즘은 없다.
* 구현 방법 : 반복문(for)과 조건문(if)을 활용해 모두 테스트.
* (ex. 윤년구하기 문제)
* 시간 복잡도 : O(N!)
<br><br>

### [완전탐색_순열]
* 확률과 통계의 순열을 응용해 모든 경우를 다 시도하는 방법.
    * 순열 : N개 수의 배열(수열)을 일렬로 나열하는 경우의 수. (nPr = n!/(n-r)!)
    * 조합 : N개 수의 배열(수열)을 순서없이 뽑는 경우의 수. (nCr = n!/r!(n-r)!)
* 구현 방법 : itertools.permutations('abcd', 2), 재귀
* (ex. 순열 구현)
* 시간 복잡도 : O(N!)
<br><br>

### [완전탐색_재귀]
* 재귀를 응용해 모든 경우를 다 시도해보는 방법.
    * 재귀 : 함수가 스스로를 다시 호출.
* 구현 방법 : 재귀함수 구조 설계.
* (ex. 순열 구현)
* 시간 복잡도 : O(N)
<br><br>

### [완전탐색_비트마스크]
* 2진수를 이용하는 컴퓨터 연산을 응용한 방법.
* 구현 방법 : 리스트 [1,2,3,4]가 있을때 2진수의 모든 경우(0001,0010,0011, ...)를 곱함. bin() 메서드 사용.
* 시간 복잡도 : O(1)
<br><br>

### [완전탐색_DFS]
* 모든 경우에 대하여, 깊이를 우선으로 모두 탐색.
    * 핵심은 방문할 노드와 방문한 노드를 두개로 나누는 것.
* 구현 방법 : 스택 혹은 재귀함수 사용.
* (ex. 노드 탐색)
* 시간 복잡도 : 행렬에서 O(N^2), 리스트에서 O(N+e)
<br><br>

### [완전탐색_BFS]
* 모든 경우에 대하여, 너비를 우선으로 모두 탐색.
    * 핵심은 방문할 노드와 방문한 노드를 두개로 나누는 것.
* 구현 방법 : 큐 사용.
* (ex. 노드 탐색)
* 시간 복잡도 : O(N^2)
<br><br>



## `[탐욕]`
* 매 상황 마다 가장 좋아 보이는 것만 선택하는 방식. 그때그때 상황에 맞는 최상의 해결책을 찾는다.
* Greedy하다는 것은 최소한의 일을 하고 싶어하는 탐욕을 뜻함.
* 장점 : 그나마 빠른 알고리즘.
* 단점 : 지역 근사값이 전역 근사값이 아닐 수 있다.
* 구현 방법 : 반복되지 않는 것은 리스트에 넣어주고, 반복되는 것은 루프로 반복해주기.
* (ex. 거스름돈 문제, 4Change, 5ForLoop)
* 시간 복잡도 : O(k) (k = 반복해야하는 수. ex. 화폐 종류)
<br><br>



## `[분할 정복]`
* 문제를 여러 부분으로 분할, 각각을 해결, 정답을 모아 제출. 각 문제는 독립적이다.
* cf. 동적 계획법(각 문제가 서로 영향을 준다.)
* 장점 : 가독성이 좋다.
* 단점 : 메모리 사용량이 많다. (스택 오버플로우)
* 구현 방법 : while문을 돌리고 각 케이스별 알고리즘을 if문으로 작성.
* (ex. 배열의 Z 탐색)
* 시간 복잡도 : O(NlogN)
<br><br>



## `[동적 프로그래밍]`
* 문제를 여러 부분으로 분할, 각각을 해결, 정답을 모아 제출. 각 문제가 서로 영향을 준다.
* cf. 분할 정복(각 문제는 독립적이다.)
* 장점 : n이 아무리 커져도 런타임이 늘지 않는다.
* 단점 : 메모리 사용량이 많다.
* 구현 방법 : 재귀함수 구조 설계. 캐싱 기법 활용.
* (ex. 피보나치 수열)
* 시간 복잡도 : O(N)
<br><br>



## `[백트래킹]`
* DFS를 진행하면서 조건에 부합하지 않을 경우 더이상 깊이 탐색을 하지 않고 넘어가서 시간을 절약한다.
* 장점 : DFS 보다는 빠르다.
* 단점 : 느리다.
* 구현 방법 : promising(조건의 유효성 판단) + pruning(가지치기)
* (ex. N과 M, N-Queen)
* 시간 복잡도 : O(N^N)
<br><br>



## `[탐색]`
* 목적에 맞는 데이터를 찾아내기 위한 알고리즘.
<br><br>

### [탐색_선형탐색]
* 맨 앞부터 순서대로 하나씩 확인하는 방법.
* 구현 방법 : 이터레이터로 하나씩 꺼낸다.
* 시간 복잡도 : O(N)
<br><br>

### [탐색_이진탐색]
* 중간지점을 기준으로 데이터를 반씩 나눠서 확인하는 방법.
* 구현 방법 : 인덱스를 활용해 처음, 중간, 마지막을 구분한다.
* 시간 복잡도 : O(logN)
<br><br>

### [탐색_해시탐색]
* 값과 index를 미리 연결해 둠으로써 짧은 시간에 탐색하는 방법.
* 구현 방법 : 딕셔너리.
* 시간 복잡도 : O(1)
<br><br>



## `[정렬]`
* 원소들을 번호 순이나 사전 순과 같이 일정한 순서대로 열거하는 알고리즘.
* 정렬을 하기위해서는 반드시 자료구조가 존재해야 한다.
<br><br>

### [정렬_버블정렬]
* 옆에 있는 원소와 비교하고 크면 뒤로 작으면 앞으로 교환하는 방법.
* 구현 방법 : 2중 for문 + if문. swap 사용.
* 시간 복잡도 : O(N^2)
<br><br>

### [정렬_선택정렬]
* 모든 숫자를 다 보고 가장 작은게 1번째, 나머지 중에 다시 가장 작은게 2번째를 반복하는 방법.
* 구현 방법 : 2중 for문 + if문. swap 사용. 최소값 인덱스 개념 사용.
* 시간 복잡도 : O(N^2)
<br><br>

### [정렬_삽입정렬]
* 기존 값들과 비교하여 가장 알맞은 자리에 삽입하는 방법.
* 구현 방법 : 2중 for문 + if문. swap 사용. 제일 뒤부터 시작.
* 시간 복잡도 : O(N^2)
<br><br>

### [정렬_병합정렬]
* 원소의 개수가 0 or 1이 되도록 모두 쪼개고, 쪼갠 역순으로 각 쪼갠 부분의 1번째 원소 끼리 크기를 비교해 병합하는 방법.
    * 쪼개진 조각이 내부적으로 정렬된 것을 이용해 비교 횟수를 줄인다.
* 구현 방법 : 재귀 + 분할정복, 어레이 차등, while 반복문.
* 시간 복잡도 : O(NlogN)
<br><br>

### [정렬_힙정렬]
* 1원소들을 모두 힙트리에 삽입, 2힙의 가장 높은 부모를 출력 후 힙에서 제거, 3가장 아래 자식 중 하나를 힙의 가장 높은 자리에 삽입, 4힙트리를 재정렬 하는 과정으로 정렬하는 방법.
* 힙트리 : 완전 이진 트리이며, 부모의 값은 자식의 값보다 반드시 큰 특징을 가지는 트리.
* 구현 방법 : 
* 시간 복잡도 : O(NlogN)
<br><br>

### [정렬_퀵정렬]
* 
* 구현 방법 : 
* 시간 복잡도 : O(NlogN)
<br><br>