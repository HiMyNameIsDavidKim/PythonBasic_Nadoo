# Classification of Algorithm

## `[알고리즘의 분류]`
* 설계기법 분류 : 완전탐색(Brute Force, 순열, 재귀, 비트마스크, DFS, BFS), 탐욕, 분할 정복, 동적 프로그래밍, 백트래킹, 조합
* 주제별 분류 : 탐색(선형탐색, 이진탐색, 순차탐색, 해시탐색), 정렬(버블정렬, 교환정렬, 선택정렬, 삽입정렬, 힙정렬, 퀵정렬, 병합정렬, 기수정렬), 그래프, 트리
<br><br>



## `[완전탐색]`
* 모든 경우를 다 시도해보는 방법.
* 장점 : 구현이 쉽다.
* 단점 : 시간이 오래걸린다.
* (ex. 윤년구하기 문제, 1LastDay)
<br><br>

### [완전탐색_Brute Force]
* 모든 경우를 다 시도해보는 방법.
    * 가장 무식한 방법이다. 알고리즘은 없다.
* 구현 방법 : 반복문(for)과 조건문(if)을 활용해 모두 테스트.
* 시간 복잡도 : O(N!)
<br><br>

### [완전탐색_순열]
* 확률과 통계의 순열을 응용해 모든 경우를 다 시도하는 방법.
    * 순열 : N개 수의 배열(수열)을 일렬로 나열하는 경우의 수. (nPr = n!/(n-r)!)
* 구현 방법 : itertools.permutations('abcd', 2)
* 시간 복잡도 : O(N!)
<br><br>

### [완전탐색_재귀]
* 재귀를 응용해 모든 경우를 다 시도해보는 방법.
    * 재귀 : 함수가 스스로를 다시 호출.
* 구현 방법 : 재귀호출 함수 구조 설계.
* 시간 복잡도 : O(N)
<br><br>

### [완전탐색_비트마스크]
* 2진수를 이용하는 컴퓨터 연산을 응용한 방법.
* 구현 방법 : 리스트 [1,2,3,4]가 있을때 2진수의 모든 경우(0001,0010,0011, ...)를 곱함. bin() 메서드 사용.
* 시간 복잡도 : O(1)
<br><br>

### [완전탐색_DFS]
* 모든 경우에 대하여, 깊이를 우선으로 모두 탐색.
    * 핵심은 방문할 노드와 방문한 노드를 두개로 나누는 것.
* 구현 방법 : 스택 혹은 재귀함수 사용.
* 시간 복잡도 : 행렬에서 O(N^2), 리스트에서 O(N+e)
<br><br>

### [완전탐색_BFS]
* 모든 경우에 대하여, 너비를 우선으로 모두 탐색.
    * 핵심은 방문할 노드와 방문한 노드를 두개로 나누는 것.
* 구현 방법 : 큐 사용.
* 시간 복잡도 : O(n^2)
<br><br>



## `[탐욕]`
* 매 상황 마다 가장 좋아 보이는 것만 선택하는 방식. 그때그때 상황에 맞는 최상의 해결책을 찾는다.
* Greedy하다는 것은 최소한의 일을 하고 싶어하는 탐욕을 뜻함.
* 장점 : 그나마 빠른 알고리즘.
* 단점 : 지역 근사값이 전역 근사값이 아닐 수 있다.
* 구현 방법 : 반복되지 않는 것은 리스트에 넣어주고, 반복되는 것은 루프로 반복해주기.
* (ex. 거스름돈 문제, 4Change, 5ForLoop)
* 시간 복잡도 : O(k) (k = 반복해야하는 수. ex. 화폐 종류)
<br><br>



## `[분할 정복]`
* 문제를 여러 부분으로 분할, 각각을 해결, 정답을 모아 제출. 각 문제는 독립적이다.
* cf. 동적 계획법(각 문제가 서로 영향을 준다.)
* 장점 : 가독성이 좋다.
* 단점 : 메모리 사용량이 많다. (스택 오버플로우)
* 구현 방법 : while문을 돌리고 각 케이스별 알고리즘을 if문으로 작성.
* (ex. 배열의 Z 탐색)
* O(NlogN)
<br><br>



## `[동적 프로그래밍]`



### [버블 정렬]
* 컴페어와 스왑을 연산하며, 더블 루프가 등장한다는 특징이 있다.
* 정렬을 한다면 반드시 자료구조가 존재해야 한다.
* (ex. 버블정렬 문제, 3BubbleSort)
* (입력 -> 소팅 -> 출력)의 구조로 설계한다.
* 소팅은 항상 2중 for 루프에 if가 들어가도록 설계된다.
<br><br>