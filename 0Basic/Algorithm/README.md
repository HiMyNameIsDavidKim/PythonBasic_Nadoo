# Algorithm

## `[알고리즘이란]`
* 문제를 해결하기 위한 절차나 방법. 컴퓨터의 입장에서 정리한 풀이.
* 이때까지 우리는 사용자 입장에서 했지만, 이제는 시스템의 입장에서 해야한다.
* 알고리즘은 반복(loop)과 조건(branch)과 시계열로만 이루어져있다.
    * 반복문은 for와 while이 있다.
    * 조건문은 if와 switch가 있다.
<br><br>

### [기계어와 자연어]
* 사용자 : 휴먼을 대변하는 단어
* 시스템 : 머신을 대변하는 단어
* 기계어 : 머신, 머신 랭귀지(ML), 숫자 number
    * 정수 int
    * 실수 float
* 자연어 : 휴먼, 내츄럴 랭귀지(NL), 문자 string
    * 기계어는 숫자로 이루어져 있는 ‘언어’.
    * 기계어는 근본적으로 2진법으로 곧 0과 1로만 이루어져 있다.
    * 1과 0은 수학이지만, 이걸 대체하는 것인 T와 F는 대수학이다.
<br><br>

### [대수학과 알고리즘의 정의]
* 대수학 : 미지수에 변수를 ‘대입’하는 기술, 그것을 ‘계산’하는 기술.
    * 코딩을 한다는 것은 수학으로 되어 있는 것을 문자로 치환해서 하는 것이므로 이또한 대수학이다.
<br><br>

* 대수는 상수와 변수의 집합이다.
    * 상수 : constant, 변하지 않는 것
    * 변수 : variable, 변하는 것
* 대수학의 시작은 ‘알콰리즈미’에 의해 시작했고, 그 이름을 따 ‘알고리즘’이라고 명했다.
<br><br>

### [알고리즘의 조건]
* Input : 반드시 0 또는 그 이상의 외부에서 제공된 자료가 존재해야 한다.
* Output : 반드시 1개 이상의 결과를 가져야 한다.
* Definiteness : 알고리즘의 각 단계는 명확하여 애매함이 없어야 한다.
* Finiteness : 알고리즘의 단계들은 유한한 횟수로 거친 후 문제를 해결하고 종료해야 한다.
* Effectiveness : 모든 연산은 사람도 유한한 시간안에 풀정도로 충분히 단순해야한다.
<br><br>

### [알고리즘 핵심 특징 3가지(대니얼 대닛)]
* Substrate neutrality : 알고리즘은 그 절차적 논리에 의해 결과를 도출하며, 재료가 갖는 인과적 힘은 알고리즘의 작동에 어떤 영향도 갖지 않는다.
* Underlying mindlessness : 알고리즘의 절차는 세분화된 일련의 단계들로 구성되며, 각각의 단계는 의미해석이 요구되지 않을 만큼 단순해야 한다.
* Guaranteed result : 알고리즘의 각 단계들이 오류 없이 수행된다면, 알고리즘은 최종 단계에서 반드시 성공적인 결과를 산출한다.
<br><br>

### [Time Complexity]
* 자료 수(n) 증가에 따라 시간 증가를 대략적인 패턴으로 나타낸 시간에 대한 복잡도.
    * 컴퓨터에서는 시간과 메모리라는 두 자원을 얼마나 소모하는지가 효율성의 중점이다.
* 알고리즘의 소요 시간을 평가하는 방법 중의 하나로, 주로 Big-O 표기법으로 나타낸다.
* O(n)을 추종할수록 좋은 알고리즘이며 O(n log n)만 되지 않아도 매우 바람직하다.
<br><br>

### [Space Complexity]
* 자료 수(n) 증가에 따라 시간 증가를 대략적인 패턴으로 나타낸 공간에 대한 복잡도.
    * 컴퓨터에서는 시간과 메모리라는 두 자원을 얼마나 소모하는지가 효율성의 중점이다.
* 알고리즘의 소요 시간을 평가하는 방법 중의 하나로, 주로 Big-O 표기법으로 나타낸다.
* (타임 컴플렉시티 보다는 중요도가 떨어진다.)
<br><br>



## `[프로그램이란]`
* 자료구조와 알고리즘의 집합.
* 프로그램을 설계할 때 어떠한 자료구조를 선택할지 가장 우선적으로 고려해야 한다.
* 자료구조가 선택되면 적용할 알고리즘은 상대적으로 명확해진다.
* (ex.4Change 에서도, 자료구조인 ‘리스트’가 위에 있고, 알고리즘은 아래에 있다.)
<br><br>

### [자료구조와 알고리즘]
* 알고리즘이 0이라면 자료구조는 1이다.
* 알고리즘이 있다면 반드시 자료구조가 있고, 자료구조가 있으면 반드시 알고리즘이 있다.
<br><br>



## `[객체 지향]`
* 프로그램을 수많은 객체라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식.
* 객체란 하나의 역할을 수행하는 ‘기능과 속성의 집합’으로 봐야한다.
* 드라이버 상태인 클래스를 정의하고, 메모리 상태인 인스턴스를 코딩하는 방식.
* cf. 함수형 프로그래밍
<br><br>

### [기본 구성 요소]
* 클래스(class) : 사용자가 정의한 데이터 타입. 기능(메서드)과 속성(프로펄티)의 집합.
    * 객체를 만들어 내기 위한 설계도이자 붕어빵 틀.
    * 파스칼의 계산기 근본 개념에서 가져옴.
    * 첫글자는 무조건 대문자
    * 일반인들은 이 클래스를 프로그램과 동등 시 여긴다.
    * 클래스의 init 메서드에 있는 것들이 곧 속성(프로펄티)이다.
* 객체(object) : 클래스의 인스턴스. 속성을 가지며, 클래스의 기능을 수행할 수 있다.
    * 클래스에 의해 정의된 모양대로 가상공간에 생성된 실체.
    * 인스턴스란, 메모리상에 할당된 것. 객체를 실체화 하면 그것을 인스턴스라고 부름.
    * 본질적으로 봤을때 클래스와 인스턴스는 모두 '객체'라고 부를 수 있다. 본질은 같고 단지 상태가 다를 뿐이다.
    * 단위 객체는 object 이고, 객체의 집합을 collection이라고 한다.
* 메서드(method) : 객체가 할 수 있는 기능.
    * 클래스 내부에 정의되어 있는 함수(=기능).
    * 데카르트의 방법서설 개념에서 가져옴.
    * 첫글자는 무조건 소문자
    * 알고리즘과 메서드는 본질적으로 같다. 메서드는 프로그래머들이 말하는 알고리즘이다.
<br><br>

### [메서드의 분류]
* Static Method : 객체가 고정적이다. IO(입출력) 메서드들은 스태틱하다. (ex. main)
* Dynamic Method : 객체가 유동적이다. 계산하는 메서드들은 다이나믹하다. (ex. solution)
    * 대수학의 변수&상수 개념과 일맥상통하다.
    * 반드시 땅(Static)이 있어야 건물(Dynamic)을 세울 수 있다.
    * 반드시 메인보드(Static)는 하나이고, 소자(Dynamic)는 여러개도 가능하다.
<br><br>

### [연산자 함수]
* 객체를 갖고 연산을 도와주는 함수.
* 연산자는 반드시 인풋이 있고 리턴이 있어야 한다. (벡터 인풋, 스칼라 리턴)
* 메서드는 크게 4가지로 나눌 수 있다.
    * 파라미터 in, 리턴 out = 연산자, 펑션(어플라이), 일반 메서드 -> y = f(x)
    * 파라미터 x, 리턴 out = 게터, 서플라이어(겟), str 메서드 -> y = f()
    * 파라미터 in, 리턴 x = 세터, 컨슈머(액셉터), init 메서드 -> f(x)
    * 파라미터 x, 리턴 x = 불가능, 쓰레기
        * 외우는 법(이닛은 세팅이다~)

### [객체지향 요소]
* Abstraction : 객체들의 공통적인 특징을 도출하는 것. 클래스를 정의하는 것 자체가 앱스트랙션이다.
* Encapsulation : 변수와 함수를 하나의 단위로 묶는 것. 클래스에 의해 구현되는 행위로, 해당 클래스의 인스턴스 생성을 통해 클래스에 포함된 모든 것에 쉽게 접근할 수 있다. init 메서드와 self를 사용하는 것이 인캡슐레이션으로 볼 수 있다.
* Inheritance : 자식 클래스가 부모 클래스의 특성을 그대로 물려받는 것. 기능의 일부만 변경하는 경우 ‘overriding’이라고 한다.
* Polymorphism : 하나의 변수or함수가 상황에 따라 다른 의미로 해석될 수 있는 것.
* Dynamic binding : Run하는 동안에 호출될 함수가 결정되며, 객체에 따라 함수가 유동적이다.
<br><br>

### [객체지향의 장단점]
* 생산성 향상 : 다형성, 객체, 캡슐화 등 SW의 재사용을 지향하기에 새로 작성하는 부담이 적다. 업그레이드도 쉽게 가능하며, 디버깅이 쉽다.
* 실세계에 대한 쉬운 모델링 : 실세계는 하나의 절차로 모델링할 수 없으므로, 많은 객체들의 상호작용으로 묘사했을때 더 쉽다.
* 보안성 향상 : 캡슐화 특징으로 데이터 은닉이 가능하여 보안성이 높다.
* 느린 실행 속도 : 캡슐화와 격리구조 때문에 절차지향 프로그래밍에 비하면 실행속도가 느리다.
<br><br>

### [모듈화]
* 기능 단위 모듈로 분해하는 설계 및 구현 기법.
* 시스템을 분해하여 추상화 하고, 재사용한다. -> 객체지향 개념과 일치한다.
<br><br>

### [함수형 프로그래밍]
* 자료처리를 수학적 함수 계산으로 취급하고, 상태와 가변 데이터를 피하는 프로그래밍.
* 기능만 있고 호출하기 전까지는 실존하지 않는다는 컨셉. 저장을 안하기 때문에 엄청나게 빠르다. -> 빠르다? 그렇다면 OOP와 섞어서 써보자.
* 객체지향 프로그래밍과는 전혀 다른 패러다임. 두개를 섞어 사용해야 효율적인 모델이 된다.
* 특징으로 순결성, 불변성, 하이어 오더가 있다.
    * 순결성 : 내부 상태를 갖지 않기 때문에 같은 입력은 항상 같은 출력을 낸다. -> side effect가 없다.
    * 불변성 : 데이터는 변하지 않는다. 변경이 필요하면 복사본을 만들어야 한다. -> 동작을 예측하기 쉽다.
    * 하이어 오더 : 여기서는 함수가 최상위다. -> 함수를 재사용할 수 있다.
<br><br>

### [무상태 프로그래밍]
* 상태 프로그래밍 : stateful, 상태를 갖는 함수형을 사용한 프로그래밍.
* 무상태 프로그래밍 : stateless, 상태를 갖지 않는 함수형을 사용한 프로그래밍.
* 속성은 비객체지향적 요소인데, 속성이 상태를 만들고, 상태는 단지 객체세계와 외부세계의 연결을 위해서만 발생한다. 따라서 속성을 만들지 않는다. (속성값을 하나로 결정하는 것이 아니라, 객체에 담아버린다.)
* RESTful은 기본적으로 무상태 환경에서 동작한다. (보안 및 인증에서 토큰 인증이 사용되며, 세션 사용은 절대로 하지 않는다.)
* 장고의 모든 return을 JsonResponse 객체로 표현하면 된다. (리액트는 request 사용.)
    * JSON은 딕셔너리(키-벨류 구조)로 되어 있다. 기본적으로 무상태이고 암호화 되어 있다.
<br><br>



## `[알고리즘의 분류]`
* 설계기법 분류 : 완전탐색(Brute Force, 순열, 재귀, 비트마스크, BFS), 축소 정복, 분할 정복, 탐욕, 동적 프로그래밍, 백트래킹, 조합
* 주제별 분류 : 탐색(선형탐색, 이진탐색, 순차탐색, 해시탐색), 정렬(버블정렬, 교환정렬, 선택정렬, 삽입정렬, 힙정렬, 퀵정렬, 병합정렬, 기수정렬), 그래프, 트리
* [링크]
<br><br>



## `[인사이트]`
* [파이썬 오피셜 자습서](https://docs.oracle.com/javase/tutorial/java/index.html)
* [오라클의 자바 오피셜 자습서](https://docs.python.org/ko/3/tutorial/index.html)
* KoNLPy : 한국어 자연어 처리 파이썬 패키지.
* 전자정부프레임워크 : 한국의 스프링.
* 스프링 : 자바를 위한 오픈소스 어플리케이션 프레임워크.
    * 한국은 자바 위에 파이썬을 올리는 형태를 쓰기 때문에 자바는 필수다.
* 브랜치와 루프 -> 클래스와 메서드 -> 개별 알고리즘(=솔루션) -> 프로그램 -> 시스템 -> 네트워크
<br><br>



## `[용어]`
* () : round brace, 튜플
* {} : curl brace, 딕셔너리
* [] : square brace, 리스트
* <> : angle brace, 안씀
* “” : double quote
* ; : semi colon
* 파라미터 : 함수에 투입되는 변수. 매개변수나 모수라고도 부른다.
<br><br>