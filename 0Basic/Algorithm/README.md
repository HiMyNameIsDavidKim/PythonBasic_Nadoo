# Algorithm

## `[알고리즘이란]`
* 문제를 해결하기 위한 절차나 방법. 컴퓨터의 입장에서 정리한 풀이.
* 이때까지 우리는 사용자 입장에서 했지만, 이제는 시스템의 입장에서 해야한다.
* 알고리즘은 반복(loop)과 조건(branch)과 시계열로만 이루어져있다.
    * 반복문은 for와 while이 있다.
    * 조건문은 if와 switch가 있다.<br><br>

### [기계어와 자연어]
* 사용자 : 휴먼을 대변하는 단어
* 시스템 : 머신을 대변하는 단어
* 기계어 : 머신, 머신 랭귀지(ML), 숫자 number
    * 정수 int
    * 실수 float
* 자연어 : 휴먼, 내츄럴 랭귀지(NL), 문자 string
    * 기계어는 숫자로 이루어져 있는 ‘언어’.
    * 기계어는 근본적으로 2진법으로 곧 0과 1로만 이루어져 있다.
    * 1과 0은 수학이지만, 이걸 대체하는 것인 T와 F는 대수학이다.<br><br>

### [대수학과 알고리즘의 정의]
* 대수학 : 미지수에 변수를 ‘대입’하는 기술, 그것을 ‘계산’하는 기술.
    * 코딩을 한다는 것은 수학으로 되어 있는 것을 문자로 치환해서 하는 것이므로 이또한 대수학이다.<br><br>

* 대수는 상수와 변수의 집합이다.
    * 상수 : constant, 변하지 않는 것
    * 변수 : variable, 변하는 것
* 대수학의 시작은 ‘알콰리즈미’에 의해 시작했고, 그 이름을 따 ‘알고리즘’이라고 명했다.<br><br>

### [알고리즘의 조건]
* Input : 반드시 0 또는 그 이상의 외부에서 제공된 자료가 존재해야 한다.
* Output : 반드시 1개 이상의 결과를 가져야 한다.
* Definiteness : 알고리즘의 각 단계는 명확하여 애매함이 없어야 한다.
* Finiteness : 알고리즘의 단계들은 유한한 횟수로 거친 후 문제를 해결하고 종료해야 한다.
* Effectiveness : 모든 연산은 사람도 유한한 시간안에 풀정도로 충분히 단순해야한다.<br><br>

### [알고리즘 핵심 특징 3가지(대니얼 대닛)]
* Substrate neutrality : 알고리즘은 그 절차적 논리에 의해 결과를 도출하며, 재료가 갖는 인과적 힘은 알고리즘의 작동에 어떤 영향도 갖지 않는다.
* Underlying mindlessness : 알고리즘의 절차는 세분화된 일련의 단계들로 구성되며, 각각의 단계는 의미해석이 요구되지 않을 만큼 단순해야 한다.
* Guaranteed result : 알고리즘의 각 단계들이 오류 없이 수행된다면, 알고리즘은 최종 단계에서 반드시 성공적인 결과를 산출한다.<br><br>

### [Time Complexity]
* 자료 수(n) 증가에 따라 시간 증가를 대략적인 패턴으로 나타낸 시간에 대한 복잡도.
    * 컴퓨터에서는 시간과 메모리라는 두 자원을 얼마나 소모하는지가 효율성의 중점이다.
* 알고리즘의 소요 시간을 평가하는 방법 중의 하나로, 주로 Big-O 표기법으로 나타낸다.
* O(n)을 추종할수록 좋은 알고리즘이며 O(n log n)만 되지 않아도 매우 바람직하다.<br><br>

### [Space Complexity]
* 자료 수(n) 증가에 따라 시간 증가를 대략적인 패턴으로 나타낸 공간에 대한 복잡도.
    * 컴퓨터에서는 시간과 메모리라는 두 자원을 얼마나 소모하는지가 효율성의 중점이다.
* 알고리즘의 소요 시간을 평가하는 방법 중의 하나로, 주로 Big-O 표기법으로 나타낸다.
* (타임 컴플렉시티 보다는 중요도가 떨어진다.)<br><br>



## `[프로그램이란]`
* 자료구조와 알고리즘의 집합.
* 프로그램을 설계할 때 어떠한 자료구조를 선택할지 가장 우선적으로 고려해야 한다.
* 자료구조가 선택되면 적용할 알고리즘은 상대적으로 명확해진다.
* (ex.4Change 에서도, 자료구조인 ‘리스트’가 위에 있고, 알고리즘은 아래에 있다.)<br><br>

### [자료구조와 알고리즘]
* 알고리즘이 0이라면 자료구조는 1이다.
* 알고리즘이 있다면 반드시 자료구조가 있고, 자료구조가 있으면 반드시 알고리즘이 있다.<br><br>



## `[객체 지향]`
* 프로그램을 수많은 객체라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식.
* 객체란 하나의 역할을 수행하는 ‘메서드와 데이터의 묶음’으로 봐야한다.
* 드라이버 상태인 클래스를 정의하고, 메모리 상태인 인스턴스를 코딩하는 방식.<br><br>

### [기본 구성 요소]
* 클래스(class) : 사용자가 정의한 데이터 타입. 속성(변수)과 기능(메서드)의 집합.
    * 객체를 만들어 내기 위한 설계도이자 붕어빵 틀.
    * 파스칼의 계산기 근본 개념에서 가져옴.
    * 첫글자는 무조건 대문자
    * 일반인들은 이 클래스를 프로그램과 동등 시 여긴다.
* 객체(object) : 클래스의 인스턴스. 속성을 가지며, 클래스의 기능을 수행할 수 있다.
    * 클래스에 의해 정의된 모양대로 가상공간에 생성된 실체.
    * 인스턴스란, 메모리상에 할당된 것. 객체를 실체화 하면 그것을 인스턴스라고 부름.
    * 본질적으로 봤을때 클래스와 인스턴스는 모두 '객체'라고 부를 수 있다.
* 메서드(method) : 객체가 할 수 있는 기능.
    * 클래스 내부에 정의되어 있는 함수(=기능).
    * 데카르트의 방법서설 개념에서 가져옴.
    * 첫글자는 무조건 소문자
    * 알고리즘과 메서드는 본질적으로 같다. 메서드는 프로그래머들이 말하는 알고리즘이다.<br><br>

### [메서드의 분류]
* Static Method : 객체가 고정적이다. IO(입출력) 메서드들은 스태틱하다. (ex. main)
* Dynamic Method : 객체가 유동적이다. 계산하는 메서드들은 다이나믹하다. (ex. solution)
    * 대수학의 변수&상수 개념과 일맥상통하다.
    * 반드시 땅(Static)이 있어야 건물(Dynamic)을 세울 수 있다.
    * 반드시 메인보드(Static)는 하나이고, 소자(Dynamic)는 여러개도 가능하다.

### [객체지향 요소]
* Abstraction : 객체들의 공통적인 특징을 도출하는 것. 클래스를 정의하는 것 자체가 앱스트랙션이다.
* Encapsulation : 변수와 함수를 하나의 단위로 묶는 것. 클래스에 의해 구현되는 행위로, 해당 클래스의 인스턴스 생성을 통해 클래스에 포함된 모든 것에 쉽게 접근할 수 있다.
* Inheritance : 자식 클래스가 부모 클래스의 특성을 그대로 물려받는 것. 기능의 일부만 변경하는 경우 ‘overriding’이라고 한다.
* Polymorphism : 하나의 변수or함수가 상황에 따라 다른 의미로 해석될 수 있는 것.
* Dynamic binding : Run하는 동안에 호출될 함수가 결정되며, 객체에 따라 함수가 유동적이다.<br><br>

### [객체지향의 장단점]
* 생산성 향상 : 다형성, 객체, 캡슐화 등 SW의 재사용을 지향하기에 새로 작성하는 부담이 적다. 업그레이드도 쉽게 가능하며, 디버깅이 쉽다.
* 실세계에 대한 쉬운 모델링 : 실세계는 하나의 절차로 모델링할 수 없으므로, 많은 객체들의 상호작용으로 묘사했을때 더 쉽다.
* 보안성 향상 : 캡슐화 특징으로 데이터 은닉이 가능하여 보안성이 높다.
* 느린 실행 속도 : 캡슐화와 격리구조 때문에 절차지향 프로그래밍에 비하면 실행속도가 느리다.<br><br>



## `[알고리즘의 분류]`
* 설계기법 분류 : 완전 탐색, 분할 정복, 탐욕, 동적 프로그래밍, 조합
    * 완전탐색 안에는 Brute Force, 순열, 재귀, 비트마스크, BFS가 있다.
* 주제별 분류 : 탐색(선형검색, 이진검색), 정렬(버블정렬, 선택정렬, 삽입정렬), 그래프<br><br>

### [Brute Force Search(완전 탐색)]
* 모든 경우를 다 시도해보는 방법.
* 가장 무식한 방법이다. (알고리즘으로 넣기 부끄러운 정도이다.)
* (ex. 윤년구하기 문제, 1LastDay)
* 반복(loop)과 조건문(branch)을 활용해 모두 테스트 하는 방법이다.<br><br>

### [Greedy(탐욕 알고리즘)]
* 매 상황 마다 가장 좋아 보이는 것만 선택하는 방식.
* 그때그때 상황에 맞는 최상의 해결책을 찾는다.
* (ex. 거스름돈 문제, 4Change, 5ForLoop)
* Greedy하다는 것은 최소한의 일을 하고 싶어하는 탐욕을 뜻함.
* 리스트 자료형을 사용해서 자료구조를 구현할 수 있음.
* 패턴이 아닌 것(같지 않은 것)과 패턴(같은 것)을 분리하면 쉬움.
* 패턴이 아닌 것은 리스트에 넣어주고, 패턴인 것은 루프로 반복해주기.<br><br>

### [Bubble Sort(버블 정렬 알고리즘))]
* 컴페어와 스왑을 연산하며, 더블 루프가 등장한다는 특징이 있다.
* 정렬을 한다면 반드시 자료구조가 존재해야 한다.
* (ex. 버블정렬 문제, 3BubbleSort)
* (입력 -> 소팅 -> 출력)의 구조로 설계한다.
* 소팅은 항상 2중 for 루프에 if가 들어가도록 설계된다.<br><br>



## `[인사이트]`
* [파이썬 오피셜 자습서](https://docs.oracle.com/javase/tutorial/java/index.html)
* [오라클의 자바 오피셜 자습서](https://docs.python.org/ko/3/tutorial/index.html)
* KoNLPy : 한국어 자연어 처리 파이썬 패키지.
* 전자정부프레임워크 : 한국의 스프링.
* 스프링 : 자바를 위한 오픈소스 어플리케이션 프레임워크.
    * 한국은 자바 위에 파이썬을 올리는 형태를 쓰기 때문에 자바는 필수다.
* 브랜치와 루프 -> 클래스와 메서드 -> 개별 알고리즘(=솔루션) -> 프로그램 -> 시스템 -> 네트워크<br><br>



## `[용어]`
* () : round brace, 튜플
* {} : curl brace, 딕셔너리
* [] : square brace, 리스트
* <> : angle brace, 안씀
* “” : double quote
* ; : semi colon
* 파라미터 : 함수에 투입되는 변수. 매개변수나 모수라고도 부른다.<br><br>










