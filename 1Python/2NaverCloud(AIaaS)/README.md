# NaverCloud(AIaaS)

## `[Set-up]`
* JDK 11 설치, JDK 11 환경변수 설정
    * 한국의 인공지능은 JDK 11이 표준이다.
* 아나콘다 설치, 아나콘다 환경변수 설정
    * 아나콘다는 데이터 사이언스 기술과 머신러닝의 방법들을 제공한다.
* 파이참 설치, 스튜던트 라이센스 발급
* 환경변수 참고
    * JAVA_HOME : C:\Program Files\jdk-11\bin
    * ANACONDA_HOME1 : C:\ProgramData\Anaconda3
    * ANACONDA_HOME2 : C:\ProgramData\Anaconda3\Scripts
    * ANACONDA_HOME3 : C:\ProgramData\Anaconda3\Library\bin
    * ANACONDA_HOME4 : C:\ProgramData\Anaconda3\Library\mingw-w64\bin<br><br>



## `[Advanced OOP]`

### [Static Method]
* 클래스 밖의 메서드를 클래스 안으로 집어넣을 수 있다.(=랩핑)
* 클래스 밖의 메서드는 스태틱 메서드라고 부른다. (클래스 안은 다이나믹 메서드)
* 화면에 구현할 것을 스태틱 메서드에 넣는다.
* (if문 main) 대신에 @staticmethod를 사용할 수 있다.
* 이때 @를 데코레이터라고 부른다.<br><br>

### [생성자와 소멸자]
* 생성자(constructor) : init 메서드, 객체 지향에서 객체의 초기화를 담당하는 서브루틴.
    * 생성자 괄호 안에 있는 것들이 property 이다.
* 소멸자(destructor) : del 메서드, 객체가 소멸될 때 자동으로 발생하는 서브루틴.
    * 생성되고 소멸이 안되면 메모리가 부족해진다. 반드시 죽여야한다.<br><br>

### [소프트웨어 디자인 패턴]
* 소프트웨어 설계의 특정 문맥에서 공통적인 문제에 대해 재사용 가능한 해결책.
* “바퀴를 다시 발명하지 마라.(Don’t reinvent the wheel.”
* Gang of Four에 의하면, 23가지 패턴으로 모두 설명이 가능하다.
    * 생성 패턴 : 추상 팩토리, 빌더, 팩토리 메서드, 프로토타입, 싱글 턴
    * 구조 패턴 : 어뎁터, 브릿지, 컴포지트, 데코레이터, 파사드, 플라이 웨이트, 프록시
    * 행위 패턴 : 책임 연쇄, 커맨드, 인터프리터, 반복자, 중재자, 메멘토, 옵서버, 상태, 전략, 템플릿 메서드, 비지터<br><br>

### [패턴 상세 고찰]
* 팩토리 패턴 : 클래스의 프로퍼티를 변경하거나 확장해야 할 때 사용하는 패턴.
    * 모든 코드를 하나하나 수정할 필요가 없으며, factory 메서드를 사용하면 된다.
    * 또한, 2차원 형태의 데이터를 가져올 때, 한줄 한줄 읽는 것이 아니라 한번에 2차원을 읽는다. (ex. [ ][ ] = abc.Abc( ))
* 프로토타입 패턴 : 생성할 클래스들의 타입이 프로토타입인 인스턴스로 부터 결정되는 패턴.
    * 객체를 만들기 위해 자기 자신을 복제한다.
    * 모델링 과정에서는 (전처리 - 프로세스 - 테스트)를 계속 반복되는데, 이과정도 프로토타입 패턴이다.
    * 팩토리 패턴과 반대되는 개념. (모델링 = 프로토타입, 완성 후 배포 = 팩토리)<br><br>

### [객체지향의 기본 구조]
* constructor -> static -> information processing -> print
* 객체지향에서 값은 크게 property(포멧), information(처리 완료), data(처리 전) 3가지로 존재한다.
    * property = 컵, information = 커피, data = 커피콩
    * constructor = property, information processing = information, static = data<br><br>



## `[Architecture]`

### [CRUD]
* 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능.
* Create, Read, Update, Delete 4가지
    * Read는 2개로 나뉘고, 전체를 보여주는 경우 List(목록). 일부를 보여주는 경우 Search(검색).
* 엔진구조 : 소프트웨어에서 계속 반복해서 돌리다가 원할때 멈추는 구조를 엔진구조라고 한다.
* 스태틱 메인 메서드는 CRUD로 구성된 엔진구조로 설계한다.<br><br>

### [MTV 패턴]
* 디자인 패턴 중의 하나. 전체 프레임워크를 3부분으로 나눈다.
* 진행 순서는 init파일 -> 데이터셋 -> 모델 -> 뷰 -> 템플릿
* Model : 모델 수립, (전처리 - 프로세스 - 테스트) 순서로 모델을 완성.
    * DB에 저장되는 데이터, 내부속성값, 클래스
* Template : 출력, 유저와 인터액션하는 인터페이스.
    * 유저에게 보여지는 화면, 스태틱메서드, html 파일
* View : 로직, 각 과정의 순서도만을 보관. 캡슐화.
    * 결과를 템플릿으로 렌더링만 함, 로직, 결과 리턴
    * 뷰가 로직이라고 해서 모델링에 대한 로직도 다 가진 것은 아니다.
* Dataset : 외부에 있는 데이터를 끌어와서 확률을 만들어주는 모듈.
    * 입출력 기능이 없고, 로직만 있는 구조.
    * 스탠다드 클래스와는 다른 데이터 클래스 구조이며, 데코레이터를 달아줘야 한다.
    * context : 파일이 저장된 경로
    * label : 답안지
 - [`작업 순서 메모`](https://github.com/HiMyNameIsDavidKim/Study/tree/main/1Python/2NaverCloud(AIaaS)/2Flask)<br><br>



## `[Advanced Python]`

### [Pythonic]
* 파이썬 스럽게 코딩하는 것. 파이써닉.
* 파이썬은 아름다운 하나의 답이 존재한다는 철학이 있다.
* 1.comprehesion 2.f-string 3.swap 4.str 메서드 5.generator 6.extended slice 7.slots 8.kwards
    * comprehesion : 축약하기. 한줄 코딩.
        * for문의 Comp. (ex. [i for i in ls])
        * if문의 Comp. (this['Survived'][this['Sex']=='male'])(if 적지 않으며 []로만 막아서 뒤에 이어서 적어주면 된다.)
    * 컴프리헨션된 자료는 반드시 자료구조 안에 담아야한다.
    * f-string : 직관적인 문자열. (ex. f”이게 f 스트링{print_fstring}이다.”)
    * swap : 스왑하는 논리. (ex. t = a, a = b, b = t)
    * 프린트 대신 str 메서드를 사용한다. (가독성을 높이기 위함)
* asterisk(*) : 리스트형 컨테이너 타입의 데이터, 가변 파라미터에 사용.
    * 가변 파라미터 : 들어오는 파라미터의 갯수를 몰라도 된다. (ex. *feature)<br><br>

### [Getter & Setter]
* 메서드를 선언할 때 데코레이터로 역할을 구분하는 것이 좋다.
* 게터 세터를 하는 이유는 모델 안에서 한번 설정한 값을 계속 반복해서 쓰기 위함이다.(심지어 파이썬 파일이 바뀌더라도 반복해서 쓸 수 있다.)
* getter : 프로퍼티를 가져오는 메서드, 반드시 리턴이 있다.
    * 데코레이터 '@property'를 사용한다.
* setter : 프로퍼티를 저장하는 메서드, 리턴이 없다.
    * 데코레이터 '@변수.setter'를 사용한다.
* 더블 언더바 메서드(ex. init, str, main)는 내부에 암호화 된 것이다.<br><br>

### [Framework]
* 알고리즘(=솔루션)에 사용되는 구조. 일반인들이 말하는 시스템.
* 파이썬 웹 프레임워크 (Django, Flask, FastAPI)
    * Flask : 마이크로 웹 프레임워크. 단순하고 가볍다. 서버 유지비가 싸다.
    * Django : 빅데이터 전용 웹 프레임워크.
    * FastAPI : 고속 전용 웹 프레임워크.
* Directory : 리소스, 자원들(DB)이 들어있음. 풀었을때 기능이 상실되지 않는다.
* Package : 소스(소스코드), 코드들이 들어있음. 풀었을때 기능이 상실된다.
    * 디렉토리와 패키지 모두 파일을 래핑하는 용도.<br><br>



## `[Data Science]`
* 다양한 종류의 데이터로부터 지식과 인사이트를 추출하는 융합분야.
* 과학적 방법론, 프로세스, 알고리즘, 시스템 등을 동원한다.
* 통계학, 데이터분석, 머신러닝, 패턴인식을 통합하는 개념으로 정의한다.<br><br>



## `[AI 수학]`
* AI에서 데이터의 입력, 출력, AI모델 구성, 학습 모든 과정이 수학적으로 표현된다.
* 인공지능은 그 자체로 확률모델이며, 학습에는 미분 개념이 포함된 최적화 기법이 사용된다.<br><br>

### [AI에 사용되는 3개의 수학]
* 선형대수학 : 기본 표현. AI 데이터는 주로 숫자 배열(=자료구조)로 표현 하는데, 선대의 벡터나 행렬과 같은 개념이다.
* 통계학 : 구조 설계. 머신러닝은 추론 통계학의 확률 분포 모델이다. 모델의 구조는 확률 분포의 형태이며, 모델의 파라미터는 확률 분포의 세부값이다.
* 미적분 : 성능 향상. 데이터가 가지고 있는 태생적 노이즈를 제거할 수 있으며, 파라미터 변화량 vs 예측값의 변화량 사이의 관계를 계산할 수 있다.<br><br>

### [텐서]
* 인공지능에서 다차원 배열(multil dimensinal array).
* 수학에서는 듀얼 모델에 대하여 곱연산을 사용해 복합적으로 연결시킨 구조. 연산자 중 하나.
* 가우스 : 텐서 개념을 만들었다. 카테시안 좌표계를 무한차원으로 확장했다.
* 벡터는 스칼라를 가로로 늘린 것이고, 매트릭스는 벡터를 세로로 늘린 것이다.
    * (T0 = 스칼라, T1 = 벡터, T2 = 매트릭스, T3 = 큐브, T4 = T4)
    * 튜플, 딕셔너리, 리스트는 T1이다.
    * T2 입장에서는 T1이 스칼라이다. (상대적인 개념)(특히나 커서는 고차원을 이해할 수 없다.)
* 캐스팅 : 차원의 이동이 일어나는 경우.
    * reduction : 차원축소, 고차원 -> 저차원 변환, (ex.cb[ ][ ][ ] : 큐브에서 스칼라로 내려감)
    * expansion : 차원확장, 저차원 -> 고차원 변환, (ex. cb mtx : T2에서 T4로 올라감)<br><br>

### [Convolution]
* 합성곱. 행렬 분해, 변환, 필터링 할 수 있다. (함수 f를 필터 g로 필터링)
* 수학에서는 f * g(t) = 적분f(T)g(t-T)dT로 나타낸다.
* 행렬 계산 예시는 아래와 같다.
* ![이미지 2022  11  7  오후 12 33](https://user-images.githubusercontent.com/112922638/200221427-807701c2-42bd-4149-aa2d-8e17d19f3193.jpg)<br><br>

## `[ML]`
* 알고리즘을 사용하여 데이터에서 패턴을 찾는 인공지능 알고리즘.
* 간단하게 정의하면 머신 랭귀지로 러닝시키는 것.
* 분야 : 1.CV(이미지 분류, 스캔, 게임), 2.NLP(분류, 요약, 이해, 수익예측, 음성인식, 구매이력)<br><br>



## `[인사이트]`
* 데미스 허사비스 : 알파고의 아버지. 구글 딥마인드의 CEO이다.
* MSA : Micro Service Architecture, 작고 독립적으로 배포가능한 서비스로 구성된 프레임워크이다.
* Kaggle : 예측모델 및 분석 대회 플랫폼.
    * 데이터 사이언티스트들이 경쟁하는 공간으로 기업이 현상금을 걸고 문제를 낸다.
    * 기초적인 머신러닝 모델의 데이터셋을 구할 수 있다. (ex.타이타닉 ML)
* 데이콘 : 확률 알고리즘에서 프로그래머스 같은 사이트.
* 판다스 : 데이터 분석에 필요한 데이터 구조와 연산을 제공하는 라이브러리. 1차원 연산은 넘파이로, 2차원 연산은 판다스로 사용하는 편이다.
* 애자일 방법론 : 신속하게 거지같이 만들어서 깨지고 고친다.<br><br>



## `[용어]`
* syntax(신택스) : NL의 grammer
* term(텀) : NL의 word
* 웹(브라우저) <-> 앱(스마트폰)
* component(컴포넌트) : 재사용이 가능한 각각의 독립된 모듈
* server(서버) : 서비스를 제공하는 프로그램
* service(서비스) : 서버가 제공하는 기능, 유저들 입장에서의 메서드 or 모듈
* client(클라이언트) : 서버와 반대되는 말, 고객
* Refactoring : 결과의 변경 없이 코드의 구조를 재조정하는 것.
* 클래스 다이어그램 : 프로그램의 설계 도면.
* API : 뷰(컨트롤러)가 만드는 객체
* NumPy(넘파이) : 기계어로 된 배열으로 선대 계산에 사용되며, 데이터를 빠르게 처리할 수 있다.
* 데이터의 기본 4유형 : 데이터는 무조건 4개 유형으로 나뉜다.
    * Nominal : 명목 데이터. 이름에 대한 데이터. (ex.카테고리)
    * Ordinal : 순서 데이터. 순서가 있는 명목 데이터. (ex. 높다 낮다)
    * Interval : 구간 데이터. 절대적 원점이 없는 구간 데이터. (ex. ‘5분 간격’)
    * Ratio : 비율 데이터. 절대적 원점이 있는 구간 데이터. (ex. 나이 돈 몸무게)<br><br>